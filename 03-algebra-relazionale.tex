\documentclass{article}

% --- Encoding e lingua ---
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}

% --- Margini e layout ---
\usepackage{geometry}
\geometry{a4paper, margin=1in}

% --- Font sans-serif ---
\usepackage[scaled]{helvet}
\renewcommand{\familydefault}{\sfdefault}

% --- Matematica ---
\usepackage{amsmath}
\usepackage{amssymb}

% --- Liste personalizzate ---
\usepackage{enumitem}

% --- Hyperlink ---
\usepackage{hyperref}

% --- Colori e sfondo nero ---
\usepackage{xcolor}
\pagecolor{black} % Commentato per una visualizzazione standard
\color{white}    % Commentato per una visualizzazione standard
\usepackage{color} % Assicurati che color sia caricato

% --- Evidenziazione del codice (richiede -shell-escape) ---
\usepackage{minted}

% --- Comandi personalizzati per algebra relazionale ---
\newcommand{\union}{\cup}
\newcommand{\intersection}{\cap}
\newcommand{\difference}{-}
\newcommand{\rename}[2]{\rho_{#1}(#2)}
\newcommand{\selectop}[2]{\sigma_{#1}(#2)}
\newcommand{\project}[2]{\pi_{#1}(#2)}
\newcommand{\cartesian}{\times}
\newcommand{\naturaljoin}{\Join}
\newcommand{\thetajoin}[2]{\Join_{#1}(#2)}

% --- Comandi personalizzati per logica ---
\newcommand{\landop}{\wedge}
\newcommand{\vel}{\vee}
\newcommand{\negop}{\neg}
\newcommand{\forallop}{\forall}
\newcommand{\existsop}{\exists}

% --- Join esterni (outer join) ---
% Ridefinizione per evitare potenziali conflitti e migliorare l'aspetto
\DeclareRobustCommand{\lj}{\text{\ensuremath{\bowtie \mkern -1.5mu \relbar}}}
\DeclareRobustCommand{\rj}{\text{\ensuremath{\relbar \mkern -1.5mu \bowtie}}}
\DeclareRobustCommand{\fj}{\text{\ensuremath{\relbar \mkern -1.5mu \bowtie \mkern -1.5mu \relbar}}}
\newcommand{\leftouterjoin}{\lj}
\newcommand{\rightouterjoin}{\rj}
\newcommand{\fullouterjoin}{\fj}


% --- Titolo ---
\title{Database: Algebra e Calcolo Relazionale}
\author{Basato sulle slide di Danilo Montesi}
\date{\today}

\begin{document}
	
	\maketitle
	
	\section{Introduzione: Linguaggi per Basi di Dati}
	
	\subsection{Tipi di Operazioni}
	I linguaggi per basi di dati si dividono in base al tipo di operazioni che permettono:
	\begin{itemize}
		\item \textbf{Operations on the schema} (Operazioni sullo schema):
		\begin{itemize}
			\item \textbf{DDL (Data Definition Language):} Per definire la struttura del database (tabelle, vincoli, ecc.).
		\end{itemize}
		\item \textbf{Operations on data} (Operazioni sui dati):
		\begin{itemize}
			\item \textbf{DML (Data Manipulation Language):} Per manipolare i dati (inserire, modificare, cancellare, interrogare).
			\begin{itemize}
				\item Query instructions (Istruzioni di interrogazione): Per estrarre i dati di interesse (\texttt{SELECT} in SQL).
				\item Update instructions (Istruzioni di aggiornamento): Per inserire nuovi dati, modificare o cancellare dati esistenti (\texttt{INSERT}, \texttt{UPDATE}, \texttt{DELETE} in SQL).
			\end{itemize}
		\end{itemize}
	\end{itemize}
	
	\subsection{Query Languages per Relational DBs}
	Le query languages possono essere classificate in base a come specificano il risultato:
	\begin{itemize}
		\item \textbf{Declarative} (Dichiarative): Specificano \textbf{cosa} (le proprietà) dei risultati che vogliamo ottenere. Il sistema decide come ottenerli.
		\item \textbf{Imperative/Procedural} (Imperative/Procedurali): Specificano \textbf{come} il risultato viene ottenuto (una sequenza di operazioni).
	\end{itemize}
	Esempi:
	\begin{itemize}
		\item \textbf{Relational Algebra:} Procedurale. Teorica, non implementata direttamente come linguaggio di query per gli utenti finali, ma alla base dei query processor dei DBMS.
		\item \textbf{Relational Calculus:} Dichiarativo. Teorico, non implementato direttamente per gli utenti finali.
		\item \textbf{SQL (Structured Query Language):} Parzialmente dichiarativo. Lo standard \underline{implementato} e più diffuso.
		\item \textbf{QBE (Query by Example):} Dichiarativo. Implementato (es. in Microsoft Access).
	\end{itemize}
	
	\section{Algebra Relazionale}
	
	L'Algebra Relazionale è un linguaggio di query procedurale definito da un insieme di operatori che operano su relazioni e producono relazioni come risultato. Gli operatori possono essere combinati (composizionali).
	
	\subsection{Operatori Fondamentali}
	\begin{itemize}
		\item Set Operators (operazioni insiemistiche): \textbf{union ($\union$), intersection ($\intersection$), difference ($-$)}. Trattano le relazioni come insiemi di tuple. Richiedono che le relazioni abbiano lo stesso schema (compatibilità di unione).
		\item \textbf{Rename ($\rho$)}: Operatore unario che cambia i nomi degli attributi o della relazione stessa.
		\item \textbf{Select ($\sigma$)}: Operatore unario che seleziona un sottoinsieme di tuple in base a un predicato.
		\item \textbf{Project ($\pi$)}: Operatore unario che seleziona un sottoinsieme di attributi (colonne) e rimuove i duplicati.
		\item \textbf{Join ($\naturaljoin, \times, \thetajoin{...}{...}$)}: Operatori binari che combinano tuple da due relazioni.
	\end{itemize}
	
	\subsection{Set Operators}
	Le relazioni sono viste come insiemi di tuple. Per poter applicare unione, intersezione o differenza, le relazioni devono avere lo \textbf{stesso schema} (stesso numero di attributi, stessi nomi e stessi domini, oppure nomi diversi ma resi compatibili con Rename).
	
	Esempi dalle slide: GRADUATED(Number, Name, Age), TECHNICIANS(Number, Name, Age).
	Schema compatibile, quindi operazioni insiemistiche dirette:
	\begin{itemize}
		\item \texttt{GRADUATED} $\union$ \texttt{TECHNICIANS}: Tutte le tuple che sono in GRADUATED o in TECHNICIANS (o in entrambe).
		\item \texttt{GRADUATED} $\intersection$ \texttt{TECHNICIANS}: Tutte le tuple che sono sia in GRADUATED che in TECHNICIANS.
		\item \texttt{GRADUATED} $-$ \texttt{TECHNICIANS}: Tutte le tuple che sono in GRADUATED ma non in TECHNICIANS.
	\end{itemize}
	Se avessimo FATHERHOOD(Father, Child) e MOTHERHOOD(Mother, Child), per fare l'unione, dovremmo rinominare: $\rename{\text{Father} \leftarrow \text{Mother}}{MOTHERHOOD} \union \text{FATHERHOOD}$.
	
	\subsection{Renaming ($\rho$)}
	\begin{itemize}
		\item Operatore \textbf{unario}.
		\item Usato per \textbf{cambiare il nome degli attributi} o della relazione stessa. Lo schema cambia, i dati rimangono uguali.
		\item Sintassi per attributi: $\rename{NewName \leftarrow OldName}{RELATION}$. Esempio: $\rename{Parent \leftarrow Father}{FATHERHOOD}$ crea una nuova relazione identica a FATHERHOOD ma con l'attributo 'Father' rinominato 'Parent'.
		\item Sintassi per relazione: $\rename{NewRelationName}{RELATION}$.
	\end{itemize}
	Il renaming è fondamentale per rendere compatibili gli schemi per le operazioni insiemistiche o per distinguere attributi con lo stesso nome provenienti da relazioni diverse in un join (anche se il natural join fa questo implicitamente, è esplicito in theta-join/equi-join notazionali come visto nelle slide).
	
	\subsection{Selection ($\sigma$)}
	\begin{itemize}
		\item Operatore \textbf{unario}.
		\item Restituisce le tuple (righe) che soddisfano un \textbf{predicato} (condizione booleana).
		\item Lo schema del risultato è lo \textbf{stesso} dello schema di input.
		\item Sintassi: $\selectop{Predicate}{RELATION}$.
		\item Predicate: espressione booleana sugli attributi della relazione (es. $Salary > 50$, $Office = 'Milan'$, $Surname = Office$).
		\item Corrisponde alla clausola \texttt{WHERE} in SQL:
		\begin{minted}{sql}
			SELECT * FROM Employee WHERE Salary > 50;
			-- Corrisponde a: sigma_{Salary > 50}(EMPLOYEE)
		\end{minted}
	\end{itemize}
	
	\subsection{Projection ($\pi$)}
	\begin{itemize}
		\item Operatore \textbf{unario}.
		\item Restituisce una relazione con solo gli \textbf{attributi specificati} (colonne).
		\item Le \textbf{tuple duplicate vengono rimosse} nel risultato (poiché le relazioni sono insiemi).
		\item Lo schema del risultato è un \textbf{sottoinsieme} dello schema di input.
		\item Sintassi: $\project{AttributeList}{RELATION}$.
		\item Corrisponde alla clausola \texttt{SELECT} (senza \texttt{DISTINCT}) in SQL:
		\begin{minted}{sql}
			SELECT Number, Surname FROM Employee;
			-- Corrisponde a: pi_{Number, Surname}(EMPLOYEE)
		\end{minted}
		\item \textbf{Cardinalità:} La cardinalità dell'output è \textbf{al massimo} quella dell'input. Può essere minore se la proiezione su un sottoinsieme di attributi causa duplicati che vengono rimossi. È uguale alla cardinalità dell'input se AttributeList include una superchiave della relazione.
	\end{itemize}
	
	\subsection{Combinazione di Selection e Projection}
	\begin{itemize}
		\item Selection filtra \textbf{orizzontalmente} (righe).
		\item Projection filtra \textbf{verticalmente} (colonne).
		\item Combinandoli, si estraggono tuple specifiche e solo i loro attributi desiderati: $\project{AttributeList}{\selectop{Predicate}{RELATION}}$.
		\item Esempio: Restituire numero e cognome degli impiegati con stipendio > 50:
		$$ \pi_{\text{Number, Surname}}(\sigma_{\text{Salary > 50}}(\text{EMPLOYEE})) $$
		Corrisponde a:
		\begin{minted}{sql}
			SELECT Number, Surname
			FROM Employee
			WHERE Salary > 50;
		\end{minted}
	\end{itemize}
	Limiti: Questi operatori da soli permettono di estrarre informazioni solo da una \textbf{singola relazione}. Non permettono di correlare dati tra relazioni diverse o tuple diverse della stessa relazione in modo complesso.
	
	\subsection{Join}
	\begin{itemize}
		\item Operatore \textbf{binario}.
		\item Permette di \textbf{combinare tuple} da due relazioni diverse in base a una condizione.
		\item È essenziale per correlare informazioni distribuite su più tabelle, come si fa con \texttt{JOIN} in SQL.
	\end{itemize}
	
	\subsubsection{Cartesian Product ($\times$)}
	\begin{itemize}
		\item Operatore binario.
		\item Combina \textbf{ogni tupla} della prima relazione con \textbf{ogni tupla} della seconda.
		\item Sintassi: $R_1 \times R_2$.
		\item Lo schema del risultato è l'unione degli attributi di $R_1$ e $R_2$. Se ci sono attributi con lo stesso nome, vengono qualificati (es. $R1.Attr$, $R2.Attr$).
		\item La cardinalità del risultato è $|R_1| \times |R_2|$.
		\item È raramente usato da solo in pratica; è più utile quando seguito da una Selection per filtrare le combinazioni desiderate.
	\end{itemize}
	
	\subsubsection{Theta-Join ($\thetajoin{Condition}{...}$)}
	\begin{itemize}
		\item Operatore binario definito come una Selection sul Cartesian Product: $R_1 \thetajoin{Condition}{R_2} = \selectop{Condition}{R_1 \times R_2}$.
		\item Permette di specificare una \textbf{condizione arbitraria} (Condition, tipicamente con operatori $=, <, >, \leq, \geq, \neq$) per combinare le tuple.
		\item Sintassi: $R_1 \thetajoin{C}{R_2}$, dove $C$ è la condizione.
	\end{itemize}
	
	\subsubsection{Equi-Join}
	\begin{itemize}
		\item Un caso speciale di Theta-Join in cui la condizione $C$ è una \textbf{congiunzione di uguaglianze} ($=$).
		\item È molto comune ed efficiente. Permette di combinare tuple quando i valori di specifici attributi (anche con nomi diversi) sono uguali.
		\item Esempio: Combinare EMPLOYEE e DEPARTMENT basandosi sull'uguaglianza tra EMPLOYEE.Dept e DEPARTMENT.Code:
		$$ \text{EMPLOYEE} \thetajoin{\text{EMPLOYEE.Dept = DEPARTMENT.Code}}{\text{DEPARTMENT}} $$
		Corrisponde a un \texttt{JOIN ON} in SQL:
		\begin{minted}{sql}
			SELECT *
			FROM Employee JOIN Department
			ON Employee.Dept = Department.Code;
		\end{minted}
	\end{itemize}
	
	\subsubsection{Natural Join ($\naturaljoin$)}
	\begin{itemize}
		\item Operatore binario.
		\item Combina tuple basandosi sull'\textbf{uguaglianza di valore su tutti gli attributi con lo stesso nome}.
		\item Lo schema del risultato è l'unione degli attributi di entrambe le relazioni, con gli attributi in comune che appaiono una sola volta.
		\item Sintassi: $R_1 \naturaljoin R_2$.
		\item Può essere definito in termini di Theta-Join e Projection. Esempio: se EMPLOYEE ha (Number, Name, Dept) e DEPARTMENT ha (Dept, Chief), EMPLOYEE $\naturaljoin$ DEPARTMENT combina su 'Dept' e il risultato avrà schema (Number, Name, Dept, Chief).
		\item Corrisponde, in molti casi, a \texttt{JOIN USING} o \texttt{NATURAL JOIN} in SQL, ma è importante essere precisi perché SQL ha sottili differenze o preferisce la notazione esplicita con \texttt{ON}.
		\begin{minted}{sql}
			SELECT *
			FROM Employee NATURAL JOIN Department; -- Joins on 'Dept'
			-- Equivalente (spesso preferito per chiarezza):
			SELECT *
			FROM Employee JOIN Department USING (Dept);
		\end{minted}
	\end{itemize}
	
	\subsubsection{Cardinalità del Risultato del Join}
	\begin{itemize}
		\item Il numero di tuple nel risultato di un join $R_1 \naturaljoin R_2$ (o $R_1 \thetajoin{C}{R_2}$) è compreso tra 0 e $|R_1| \times |R_2|$.
		\item Se l'attributo di join è una \textbf{chiave (PK) in $R_2$}, allora ogni tupla di $R_1$ può trovare al massimo una corrispondenza in $R_2$ (se esiste). La cardinalità è tra 0 e $|R_1|$.
		\item Se l'attributo di join è una \textbf{chiave (PK) in $R_2$} e c'è un \textbf{vincolo di integrità referenziale} (Foreign Key in $R_1$ che referenzia la PK in $R_2$, non NULL), allora ogni tupla di $R_1$ troverà \underline{esattamente} una corrispondenza in $R_2$. La cardinalità è esattamente $|R_1|$.
	\end{itemize}
	
	\subsubsection{Inner Join vs Outer Join}
	\begin{itemize}
		\item Il Join standard (Natural, Theta, Equi) è un \textbf{Inner Join}. Discarda le tuple che non trovano corrispondenza nell'altra relazione ("left out").
		\item Gli \textbf{Outer Join} mantengono le tuple che non trovano corrispondenza, riempiendo con valori \textbf{NULL} per gli attributi della relazione mancante.
		\item Tipi di Outer Join:
		\begin{itemize}
			\item \textbf{Left Outer Join ($\leftouterjoin$):} Mantiene tutte le tuple della relazione \textbf{sinistra}. Corrisponde a \texttt{LEFT JOIN} o \texttt{LEFT OUTER JOIN} in SQL.
			\item \textbf{Right Outer Join ($\rightouterjoin$):} Mantiene tutte le tuple della relazione \textbf{destra}. Corrisponde a \texttt{RIGHT JOIN} o \texttt{RIGHT OUTER JOIN} in SQL.
			\item \textbf{Full Outer Join ($\fullouterjoin$):} Mantiene tutte le tuple da \textbf{entrambe} le relazioni. Corrisponde a \texttt{FULL JOIN} o \texttt{FULL OUTER JOIN} in SQL.
		\end{itemize}
	\end{itemize}
	
	\subsection{Espressioni Equivalenti in Algebra Relazionale}
	Due espressioni di Algebra Relazionale sono equivalenti se producono lo stesso risultato su qualsiasi istanza valida del database (lo stato del database può cambiare, ma l'equivalenza deve valere sempre).
	Le regole di equivalenza sono cruciali per l'\textbf{ottimizzazione delle query} nei DBMS. Il query optimizer riscrive le query in forme equivalenti ma più efficienti.
	
	Esempi di regole di equivalenza (quelle più importanti per l'efficienza):
	\begin{itemize}
		\item \textbf{Pushing selections down:} È spesso più efficiente applicare le selezioni \textbf{il prima possibile} per ridurre la dimensione delle relazioni intermedie.
		$$ \selectop{C_1 \landop C_2}{R} = \selectop{C_1}{\selectop{C_2}{R}} $$
		$$ \selectop{C}{R_1 \times R_2} = \selectop{C}{R_1} \times R_2 \quad (\text{se } C \text{ solo su attr di } R_1) $$
		$$ \selectop{C}{R_1 \times R_2} = R_1 \times \selectop{C}{R_2} \quad (\text{se } C \text{ solo su attr di } R_2) $$
		$$ \selectop{C_1 \landop C_2}{R_1 \times R_2} = \selectop{C_1}{R_1} \times \selectop{C_2}{R_2} \quad (\text{se } C_1 \text{ solo su } R_1, C_2 \text{ solo su } R_2) $$
		Questo è il motivo per cui una query SQL con \texttt{WHERE} dopo un \texttt{FROM} con più tabelle è spesso più efficiente di un \texttt{SELECT * FROM R1, R2 WHERE ...}, perché il DBMS può "spingere" le condizioni \texttt{WHERE} (selection) verso le tabelle individuali o inserirle direttamente nel JOIN.
		\item \textbf{Pushing projections down:} È spesso più efficiente applicare le proiezioni \textbf{il prima possibile} per ridurre la dimensione (larghezza) delle relazioni intermedie. Bisogna fare attenzione a non rimuovere attributi necessari per operazioni successive (es. join o selection).
		$$ \project{X}{R_1 \times R_2} = \project{X_1}{R_1} \times \project{X_2}{R_2} \quad (\text{dove } X = X_1 \cup X_2, X_1 \subseteq \text{schema}(R_1), X_2 \subseteq \text{schema}(R_2)) $$
		Per i join, bisogna proiettare solo dopo il join, ma si possono proiettare *prima* gli attributi che non servono *né per la condizione di join né per le proiezioni finali*.
		$$ \project{X_1 \cup Y_2}{R_1(X_1 \cup Y_1) \naturaljoin R_2(X_2 \cup Y_2)} = \project{X_1 \cup Y_1}{R_1} \naturaljoin \project{X_2 \cup Y_2}{R_2} $$
		(Questa è una semplificazione; le regole complete considerano gli attributi usati nella condizione di join e quelli proiettati alla fine). L'idea è rimuovere colonne non necessarie il prima possibile.
		\item La \textbf{proiezione non è distributiva sulla differenza}. $\pi_X(R_1 - R_2) \neq \pi_X(R_1) - \pi_X(R_2)$.
		\item Molte proprietà insiemistiche (commutatività, associatività) valgono per join, unione, intersezione, ma \textbf{non per la differenza}.
	\end{itemize}
	\textbf{Nota importante:} Non è lo scopo del corso imparare a riscrivere manualmente le query per l'efficienza in Algebra Relazionale. I moderni DBMS lo fanno automaticamente tramite il query optimizer. L'obiettivo è capire i concetti e le trasformazioni possibili.
	
	\subsection{Selection con valori NULL}
	\begin{itemize}
		\item In presenza di valori \texttt{NULL}, le espressioni booleane possono avere tre valori: \textbf{TRUE}, \textbf{FALSE}, \textbf{UNKNOWN}.
		\item La Selection ($\sigma$) restituisce solo le tuple per cui il predicato è \textbf{TRUE}. Le tuple per cui è FALSE o UNKNOWN vengono scartate.
		\item Questo significa che un predicato come $\sigma_{Age > 30 AND Age <= 30}(PEOPLE)$ non restituirà tutte le persone se alcune hanno Age = NULL, perché per queste tuple la condizione $Age > 30 AND Age <= 30$ sarà UNKNOWN.
		\item Per gestire i NULL nelle selezioni, si usano predicati speciali come \texttt{IS NULL} e \texttt{IS NOT NULL}.
		\item Esempio: Selezionare le persone con Age maggiore di 40 \textbf{o} con Age NULL:
		$$ \sigma_{\text{Age > 40 OR Age IS NULL}}(\text{PEOPLE}) $$
		In SQL:
		\begin{minted}{sql}
			SELECT *
			FROM People
			WHERE Age > 40 OR Age IS NULL;
		\end{minted}
	\end{itemize}
	Teoricamente si potrebbe usare una logica a 3 valori, ma nella pratica standard dei database si considera UNKNOWN come "non TRUE" ai fini della selezione.
	
	\subsection{Views}
	\begin{itemize}
		\item Una View è una \textbf{tabella virtuale} definita da una query. Non contiene dati propri; mostra i dati delle tabelle base sottostanti.
		\item Utili per fornire \textbf{rappresentazioni diverse} dei dati o \textbf{sottoschemi personalizzati} (Schema Esterno nell'architettura ANSI/SPARC).
		\item Permettono agli utenti di vedere solo i dati di loro interesse e con la struttura desiderata, nascondendo la complessità delle tabelle base.
		\item Possono anche servire come \textbf{strumento di programmazione} per semplificare query complesse suddividendole o riusando definizioni.
	\end{itemize}
	
	\subsubsection{Tipi di Views}
	\begin{itemize}
		\item \textbf{Virtual Relations (Views):} La definizione comune. La query sulla view viene \textbf{riscritta} dal DBMS in una query sulle tabelle base sottostanti. Non c'è storage separato per la view. Ampiamente supportate. Non migliorano l'efficienza dell'esecuzione (la query riscritta viene ottimizzata).
		\item \textbf{Materialized Views:} La query che definisce la view viene eseguita e il risultato viene \textbf{memorizzato fisicamente}. Forniscono accesso più veloce (lettura) ma occupano spazio e devono essere mantenute aggiornate quando le tabelle base cambiano (aggiornamenti lenti). Gli aggiornamenti \textit{sulla} materialized view sono raramente supportati direttamente.
	\end{itemize}
	
	\subsubsection{Esempio di View (Algebra Relazionale)}
	Definiamo una view \texttt{SUPERVISOR} che combina AFFILIATION e MANAGEMENT:
	\begin{itemize}
		\item \texttt{AFFILIATION(Employee, Dept)}
		\item \texttt{MANAGEMENT(Dept, Chief)}
	\end{itemize}
	La view \texttt{SUPERVISOR} potrebbe mostrare quale impiegato è supervisionato da quale Chief, unendo le due tabelle sul dipartimento:
	$$ \text{SUPERVISOR} := \project{\text{Employee, Chief}}(\text{AFFILIATION} \naturaljoin \text{MANAGEMENT}) $$
	(Assumendo che gli attributi di join abbiano lo stesso nome o siano gestiti implicitamente dal natural join, altrimenti si userebbe un equi-join esplicito dopo un eventuale rename).
	
	Query sulla view: Trova gli impiegati supervisionati da 'Mori'.
	$$ \selectop{\text{Chief='Mori'}}{\text{SUPERVISOR}} $$
	Il DBMS riscrive questa query espandendo la definizione della view:
	$$ \selectop{\text{Chief='Mori'}}{(\project{\text{Employee, Chief}}(\text{AFFILIATION} \naturaljoin \text{MANAGEMENT}))} $$
	Questo è l'query processing di base per le virtual views.
	
	\subsubsection{Aggiornare le Views (Incremental Updates)}
	Aggiornare una view significa modificare i dati nelle tabelle base in modo che la view aggiornata rifletta la modifica.
	\begin{itemize}
		\item Per ogni aggiornamento sulla view deve esserci una \textbf{corrispondente (e possibilmente unica) modifica sulle tabelle base}.
		\item Non è sempre univoco capire quali tuple delle tabelle base modificare per riflettere un cambiamento nella view.
		\item Quindi, solo un \textbf{sottoinsieme limitato} di views sono aggiornabili (tipicamente views semplici definite su una singola tabella base senza aggregazioni, raggruppamenti, ecc.).
	\end{itemize}
	
	\subsection{Notazione alternativa per il Join (Orientata a SQL)}
	Le slide presentano anche una notazione alternativa per il join e la proiezione, più vicina a come SQL gestisce gli attributi qualificati e meno focalizzata sul natural join implicito.
	\begin{itemize}
		\item Si distinguono attributi con lo stesso nome usando la notazione \texttt{Relation.Attribute} (es. \texttt{EMPLOYEE.Wage}, \texttt{CHIEF.Wage}). Questo è standard in SQL.
		\item Le query join esplicite sono preferite (theta-join con $=$, o equi-join).
		\item Esempio con questa notazione (query per impiegati che guadagnano più del loro capo):
		$$ \project{\text{E.Number, E.Name, E.Wage, C.Number AS NumC, C.Name AS NameC, C.Wage AS WageC}}{(\text{EMPLOYEE AS E} \thetajoin{\text{E.Dept = M.Dept}}{(\text{MANAGEMENT AS M} \thetajoin{\text{M.Chief = C.Number}}{\text{EMPLOYEE AS C}})} \thetajoin{\text{E.Wage > C.Wage}}{()} } $$
		Questa notazione esplicita con alias (AS E, AS M, AS C) e condizioni di join è molto più vicina all'SQL reale:
		\begin{minted}{sql}
			SELECT E.Number, E.Name, E.Wage, C.Number AS NumC, C.Name AS NameC, C.Wage AS WageC
			FROM EMPLOYEE AS E
			JOIN MANAGEMENT AS M ON E.Dept = M.Dept
			JOIN EMPLOYEE AS C ON M.Chief = C.Number -- C alias for the chief employee
			WHERE E.Wage > C.Wage;
		\end{minted}
		L'uso degli alias e delle qualificazioni \texttt{E.Wage} vs \texttt{C.Wage} risolve l'ambiguità.
	\end{itemize}
	
	\section{Calcolo Relazionale}
	Una famiglia di linguaggi \textbf{dichiarativi} basati sulla First Order Logic. Permettono di specificare le proprietà del risultato desiderato senza descrivere la procedura per ottenerlo.
	
	\subsection{Domain Relational Calculus (DRC)}
	\begin{itemize}
		\item Basato su variabili che rangeano sui \textbf{domini dei valori} (es. una variabile \texttt{m} potrebbe assumere tutti i possibili valori del dominio dei numeri di impiegato).
		\item Sintassi generale: $\{x_1, x_2, \dots, x_k | \text{Formula}(x_1, \dots, x_k)\}$. Più precisamente, specificando gli attributi: $\{ A_1: x_1, \dots, A_k: x_k | \text{Formula}(x_1, \dots, x_k) \}$.
		\item Formula: una formula della logica del primo ordine che può includere:
		\begin{itemize}
			\item Predicati che rappresentano le relazioni (es. $EMPLOYEE(m, n, a, w)$ significa "esiste una tupla nella relazione EMPLOYEE con valori m, n, a, w per i rispettivi attributi Number, Name, Age, Wage").
			\item Predicati di confronto ($x > 40$, $x = y$).
			\item Operatori logici ($\landop, \vel, \negop$).
			\item Quantificatori ($\forallop, \existsop$) sulle variabili (rangeano sull'intero dominio).
		\end{itemize}
		\item Semantica: Il risultato è l'insieme delle tuple $(v_1, \dots, v_k)$ di valori per le variabili $(x_1, \dots, x_k)$ tali che la Formula è vera quando le variabili sono sostituite dai valori corrispondenti. Gli attributi della tupla risultante sono $A_1, \dots, A_k$.
		\item Esempio: Restituire Numero, Nome, Età, Stipendio degli impiegati con stipendio > 40.
		$$ \{ \text{Number}: m, \text{Name}: n, \text{Age}: a, \text{Wage}: w \mid \text{EMPLOYEE}(m, n, a, w) \landop w > 40 \} $$
		\item Contro: Può essere prolisso. Permette di scrivere formule "domain-dependent" che non sono esprimibili in Algebra Relazionale (es. ${A: x | ¬R(A: x)}$ - tutti i valori nel dominio di A che NON compaiono in R; l'algebra relazionale può solo operare sui valori *presenti* nelle relazioni). Si cerca di usare il DRC solo per query "domain-independent" (quelle esprimibili in RA).
	\end{itemize}
	
	\subsection{Tuple Relational Calculus with Range Declarations (TRC-RD)}
	\begin{itemize}
		\item Basato su variabili che rangeano su \textbf{intere tuple} di specifiche relazioni. Ogni variabile è dichiarata per rangeare su una relazione.
		\item Sintassi generale: $\{ \text{TargetList} \mid \text{RangeList} \mid \text{Formula} \}$.
		\item RangeList: dichiara le variabili di tupla e su quale relazione rangeano (es. $e \in \text{EMPLOYEE}$, o $e(\text{EMPLOYEE})$ nella notazione delle slide).
		\item TargetList: specifica quali attributi delle variabili di tupla compaiono nel risultato (es. $e.Number$, $e.Name$, o $e.(Number, Name, Age)$ o $e.*$ per tutti gli attributi).
		\item Formula: una formula logica che usa gli attributi delle variabili di tupla (es. $e.Wage > 40$).
		\item Semantica: L'insieme delle tuple formate dagli attributi specificati in TargetList, per le quali esiste un'assegnazione di tuple alle variabili in RangeList che soddisfa la Formula.
		\item Esempio: Restituire Numero, Nome, Età, Stipendio degli impiegati con stipendio > 40.
		$$ \{ e.\text{*} \mid e(\text{EMPLOYEE}) \mid e.\text{Wage} > 40 \} $$
		Questo è più conciso del DRC per molte query.
		\item Esempio: Restituire numero, nome e età di tutti gli impiegati (proiezione).
		$$ \{ e.\text{(Number, Name, Age)} \mid e(\text{EMPLOYEE}) \mid \text{TRUE} \} $$
		La formula TRUE indica che non ci sono ulteriori condizioni di selezione sulle tuple.
	\end{itemize}
	
	\subsection{Equivalenza tra Calcolo e Algebra}
	\begin{itemize}
		\item Il \textbf{Domain Relational Calculus} (limitato alle query domain-independent) e il \textbf{Relational Algebra} sono \textbf{equivalenti} nel loro potere espressivo. Qualsiasi query esprimibile nell'uno è esprimibile nell'altro.
		\item Il \textbf{Tuple Relational Calculus with Range Declarations} è anch'esso \textbf{equivalente} a DRC (domain-independent) e RA.
		\item Questo è un risultato fondamentale nella teoria dei database relazionali.
	\end{itemize}
	
	\section{Oltre l'Algebra e il Calcolo Relazionale Standard}
	
	L'Algebra e il Calcolo Relazionale standard hanno dei limiti:
	\begin{itemize}
		\item Possono solo \textbf{estrarre} valori presenti nel database, non \textbf{computare nuovi valori} (es. calcolare un'imposta sul salario, fare una somma, una media). Le estensioni come l'aggregazione (SUM, AVG, COUNT) o le operazioni aritmetiche nelle proiezioni/selezioni sono state aggiunte in linguaggi pratici come SQL.
		\item Non possono esprimere query che richiedono un \textbf{numero arbitrario e a priori sconosciuto di join}. L'esempio classico è la \textbf{Transitive Closure}.
	\end{itemize}
	
	\subsection{Transitive Closure}
	\begin{itemize}
		\item Data una relazione binaria $R$ su un insieme $X$ (es. "c'è un volo diretto da X a Y"), la Transitive Closure $R^+$ è la più piccola relazione su $X$ che contiene $R$ ed è transitiva (se XRY e YRZ, allora X$R^+$Z).
		\item Nel caso dei voli, X$R^+$Y significa "è possibile volare da X a Y (con uno o più scali)".
		\item In Algebra Relazionale, per trovare tutti gli impiegati e i loro superiori diretti o indiretti (la relazione SUPERVISOR è la relazione base "direttamente supervisionato da"), dovrei fare:
		\begin{itemize}
			\item Superiore diretto: SUPERVISOR
			\item Superiore di 2 livelli: SUPERVISOR $\naturaljoin$ SUPERVISOR (rinominando gli attributi intermedi per il join)
			\item Superiore di 3 livelli: SUPERVISOR $\naturaljoin$ SUPERVISOR $\naturaljoin$ SUPERVISOR
			\item ...e fare l'unione di tutti questi risultati.
		\end{itemize}
		\item Il problema è che non so a priori quanti livelli di supervisione (quanti join) potrebbero esistere in una data istanza del database. L'altezza della gerarchia potrebbe essere arbitraria.
		\item Pertanto, la Transitive Closure \textbf{non è esprimibile} in Algebra Relazionale o Calcolo Relazionale standard, che sono "first-order".
		\item SQL moderno ha estensioni per gestire questo, in particolare le \textbf{Common Table Expressions (CTE) ricorsive} (\texttt{WITH RECURSIVE}).
	\end{itemize}
	
	\subsection{Datalog}
	\begin{itemize}
		\item Un linguaggio di programmazione logica orientato ai database, basato su Prolog.
		\item Utilizza \textbf{regole} nella forma \texttt{head <- body} (congiunzione di predicati).
		\item Distingue tra:
		\begin{itemize}
			\item \textbf{Predicati Estensionali:} Corrispondono alle tabelle base del database. Sono fatti noti a priori.
			\item \textbf{Predicati Intensionali:} Definiti da regole. Corrispondono a viste derivate o a fatti che possono essere inferiti.
		\end{itemize}
		\item Query: si chiede se un predicato è vero con un \texttt{?}. Esempio: \texttt{?richer(m, n, a, w)}.
		\item Esempio di regola (equivalente a una Selection in RA):
		\begin{minted}{prolog}
			richer(M, N, A, W) :- employee(M, N, A, W), W > 40.
			-- Leggi: "Una tupla (M,N,A,W) e' nel predicato richer SE una tupla (M,N,A,W) e' nel predicato employee E W > 40."
			-- Corrisponde a: RICH PEOPLE = select_{Wage > 40}(EMPLOYEE)
		\end{minted}
		\item Esempio di regola (equivalente a un Join):
		\begin{minted}{prolog}
			chief_of_rich(C) :- employee(M, N, A, W), W > 40, supervisor(C, M).
			-- Leggi: "C e' un chief_of_rich SE (M,N,A,W) e' un employee, W > 40, E C e' il supervisore di M."
			-- Corrisponde a: pi_{Chief}(select_{Wage > 40}(EMPLOYEE naturaljoin SUPERVISOR))
		\end{minted}
		\item Datalog supporta la \textbf{ricorsione} definendo predicati intensionali in termini di sé stessi. Questo permette di esprimere la Transitive Closure.
		\begin{minted}{prolog}
			super_chief(E, C) :- supervisor(E, C). -- Regola base (supervisore diretto)
			super_chief(E, C) :- supervisor(E, C'), super_chief(C', C). -- Regola ricorsiva (supervisore indiretto)
			-- super_chief(E, C) e' vero se C e' il supervisore diretto di E, OPPURE se C' e' il supervisore diretto di E E C e' un super_chief di C'.
		\end{minted}
		\item Questo insieme di regole definisce il predicato \texttt{super\_chief(E, C)} come la Transitive Closure della relazione \texttt{supervisor(E, C)}.
		\item \textbf{Potere Espressivo di Datalog:}
		\begin{itemize}
			\item Datalog non ricorsivo (con o senza negazione) è equivalente a RA/Calcolo standard.
			\item Datalog \textbf{ricorsivo} (con negazione) è \textbf{più espressivo} di RA/Calcolo standard.
		\end{itemize}
	\end{itemize}
	
	\section{Conclusione}
	Abbiamo esplorato i fondamenti dei linguaggi di interrogazione relazionali: l'Algebra Relazionale (procedurale) e il Calcolo Relazionale (dichiarativo). Abbiamo visto che, per le query "first-order", questi linguaggi sono equivalenti. Abbiamo anche identificato i loro limiti, in particolare l'incapacità di esprimere computazioni (come aggregazioni) e la Transitive Closure. Linguaggi pratici come SQL hanno estensioni per superare queste limitazioni, mentre linguaggi teorici come Datalog mostrano come la ricorsione permetta di esprimere concetti come la Transitive Closure.
	
\end{document}